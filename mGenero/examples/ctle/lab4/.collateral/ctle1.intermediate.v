
/****************************************************************
* This code is automatically generated by "mGenero"
* at Wed, 20 Feb 2019 12:47:49.
*
* Copyright (c) 2014-Present by Stanford University. All rights reserved.
*
* The information and source code contained herein is the property
* of Stanford University, and may not be disclosed or reproduced
* in whole or in part without explicit written authorization from
* Stanford University.
* For more information, contact bclim@stanford.edu
****************************************************************/
/****************************************************************

Copyright (c) 2018 Stanford University. All rights reserved.

The information and source code contained herein is the 
property of Stanford University, and may not be disclosed or
reproduced in whole or in part without explicit written 
authorization from Stanford University.

* Filename   : amplifier.template.sv
* Author     : Byongchan Lim (bclim@stanford.edu)
* Description: SV template for an amplifier cell

* Note       :

* Todo       :
  - 

* Revision   :
  - 00/00/00 : 

****************************************************************/
/*******************************************************
* An amplifier with possible output equalization
* - Input referred voltage offset as a static parameter
* - Gain Compression
* - Dynamic behavior (a pole or two-poles with a zero)
* - 

* Calibrating metrics:
* 1. Av = gm*Rout 
* 2. Max output swing = Itail*Rout 
* 3. fp1, fp2, fz1
*******************************************************/

module ctle1 #(
  parameter real etol_vdd = 0.01, // resolution of vdd
  parameter real etol_v_icm = 0.01, // resolution of input common-mode voltage (inp+inn)/2.0
  parameter real v_os = 0.0, // input-referred static offset voltage
  parameter real etol_f = 0.0001, // error tolerance of a filter
  parameter real etol_v_fz = 0.01 // error tolerance of a v_fz input
) (
  input pwl vinn , // negative input
  input pwl vinp , // positive input
  output pwl voutn , // negative output
  output pwl voutp , // positive output
  input pwl vdd , // power supply
  input pwl vss , // ground
  input pwl v_fz  // analog input which controls degeneration resistor
);

`protect
//pragma protect 
//pragma protect begin

`get_timeunit
PWLMethod pm=new;

// map pins between generic names and user names, if they are different
pwl inn ;
pwl inp ;
pwl outn ;
pwl outp ;
assign inn = vinn ;
assign inp = vinp ;
assign voutn = outn ;
assign voutp = outp ; 
//----- BODY STARTS HERE -----

//----- SIGNAL DECLARATION -----
pwl ONE = `PWL1;
pwl ZERO = `PWL0;

pwl v_id_lim;   // limited v_id 
pwl v_oc; // output common-mode voltage
pwl v_od; // output differential voltage
pwl vid_max, vid_min; // max/min of v_id for slewing 
pwl vop, von;
pwl v_od_filtered;
pwl vop_lim, von_lim;
pwl v_id, v_icm; // differential and common-mode inputs

real t0;
real v_icm_r;
real vdd_r;
real vss_r, v_fz_r;

real fz1, fp1, fp2; // at most, two poles and a zero
real Av;    // voltage gain (gm*Rout)
real max_swing; // Max voltage swing of an output (Itail*Rout)
real vid_r; // vid<|vid_r| (max_swing/Av)
real v_oc_r;  // common-mode output voltage

event wakeup;

//----- FUNCTIONAL DESCRIPTION -----

initial ->> wakeup; // dummy event for ignition at t=0

//-- Compute differential and common-mode voltages 

  pwl _v_id[3]; pwl _v_icm[2]; real _k_v_id[3]; real _k_v_icm[2];
  assign _k_v_id = '{1.0, -1.0, v_os};
  assign _k_v_icm = '{0.5, 0.5};
  assign _v_id = '{inp, inn, ONE};
  assign _v_icm = '{inp, inn};
// diff/cm sense considering input referred offset
pwl_add #(.no_sig(3)) xidiff (.in(_v_id), .scale(_k_v_id), .out(v_id));
pwl_add #(.no_sig(2)) xicm (.in(_v_icm), .scale(_k_v_icm), .out(v_icm));

//-- System's parameter calculation

// discretization of control inputs
pwl2real #(.dv(etol_v_icm)) xp2r_v_icm (.in(v_icm), .out(v_icm_r)); // pwl-to-real of v_icm
pwl2real #(.dv(etol_vdd)) xp2r_vdd (.in(vdd), .out(vdd_r)); // pwl-to-real of vdd
pwl2real #(.dv(etol_v_fz)) xp2r_v_fz (.in(v_fz), .out(v_fz_r)); // pwl-to-real of v_fz

// updating parameters as control inputs/mode inputs change

always @(v_icm_r, vdd_r, wakeup, vss_r, v_fz_r) begin
  t0 = `get_time;

$${
digital_modes = [get_lm_equation_modes('test1', 'fp1'), get_lm_equation_modes('test3', 'v_oc'), get_lm_equation_modes('test2', 'max_swing')]
digital_cases = [digital_modes[0][0].keys(), digital_modes[1][0].keys(), digital_modes[2][0].keys()]
variable_map = {'v_icm': 'v_icm_r'}
}$$

$$[if not mode_exists('test1')]
  fp1 = $$get_lm_equation('test1', 'fp1');
  fz1 = $$get_lm_equation('test1', 'fz1');
  Av = $$get_lm_equation('test1', 'dcgain');
  fp2 = $$get_lm_equation('test1', 'fp2');
$$[else]
  case({$$(','.join(digital_cases[0]))})
$$[for m in digital_modes[0]]
  {$$(','.join(["%d'b%s" % (Pin.vectorsize(d), dec2bin('%d'%m[d], Pin.vectorsize(d))) for d in digital_cases[0]]))}: begin
    fp1 = $$get_lm_equation('test1', 'fp1', m);
    fz1 = $$get_lm_equation('test1', 'fz1', m);
    Av = $$get_lm_equation('test1', 'dcgain', m);
    fp2 = $$get_lm_equation('test1', 'fp2', m);
  end
$$[end for]
  default: begin
    fp1 = $$get_lm_equation('test1', 'fp1', digital_modes[0][0]);
    fz1 = $$get_lm_equation('test1', 'fz1', digital_modes[0][0]);
    Av = $$get_lm_equation('test1', 'dcgain', digital_modes[0][0]);
    fp2 = $$get_lm_equation('test1', 'fp2', digital_modes[0][0]);
  end
  endcase
$$[end if]

$$[if not mode_exists('test3')]
  v_oc_r = $$get_lm_equation('test3', 'v_oc');
$$[else]
  case({$$(','.join(digital_cases[1]))})
$$[for m in digital_modes[1]]
  {$$(','.join(["%d'b%s" % (Pin.vectorsize(d), dec2bin('%d'%m[d], Pin.vectorsize(d))) for d in digital_cases[1]]))}: begin
    v_oc_r = $$get_lm_equation('test3', 'v_oc', m);
  end
$$[end for]
  default: begin
    v_oc_r = $$get_lm_equation('test3', 'v_oc', digital_modes[1][0]);
  end
  endcase
$$[end if]

$$[if not mode_exists('test2')]
  max_swing = $$get_lm_equation('test2', 'max_swing');
$$[else]
  case({$$(','.join(digital_cases[2]))})
$$[for m in digital_modes[2]]
  {$$(','.join(["%d'b%s" % (Pin.vectorsize(d), dec2bin('%d'%m[d], Pin.vectorsize(d))) for d in digital_cases[2]]))}: begin
    max_swing = $$get_lm_equation('test2', 'max_swing', m);
  end
$$[end for]
  default: begin
    max_swing = $$get_lm_equation('test2', 'max_swing', digital_modes[2][0]);
  end
  endcase
$$[end if]

  vid_r = max_swing/Av;
  vid_max = '{vid_r,0,t0};       // max input 
  vid_min = '{-1.0*vid_r,0,t0};  // min input

end

//-- Model behaviors

pwl_limiter xi_lim (.scale(ONE), .maxout(vid_max), .minout(vid_min), .in(v_id), .out(v_id_lim)); // limiting input range for modeling gm compression 

pwl_vga xgain (.in(v_id_lim), .scale(Av), .out(v_od)); // differential-mode gain stage 

pwl_filter_real_w_reset #(.etol(etol_f), .en_filter(1'b1), .filter(2)) xfilter (.fz1(fz1), .fp1(fp1), .fp2(fp2), .fp_rst(0.0), .in(v_od), .in_rst(ZERO), .out(v_od_filtered), .reset(1'b0)); // differential output filtering

real2pwl #(.tr(10e-12)) r2poc (.in(v_oc_r), .out(v_oc)); // output common-mode voltage

// combine differential and common-mode output
  pwl _v_od[2]; real _k_v_od_1[2]; real _k_v_od_2[2];
  assign _v_od = '{v_oc, v_od_filtered};

  assign _k_v_od_1 = '{1.0, 0.5};
  assign _k_v_od_2 = '{1.0, -0.5};
pwl_add #(.no_sig(2)) xoutp (.in(_v_od), .scale(_k_v_od_1), .out(outp));
pwl_add #(.no_sig(2)) xoutn (.in(_v_od), .scale(_k_v_od_2), .out(outn));

//pragma protect end
`endprotect

endmodule
